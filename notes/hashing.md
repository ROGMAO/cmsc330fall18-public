# Why hashing and salting?

Storing passwords as plain-text is dangerous. If an attacker ever gets access to the database, by SQL injection or other means, they can steal the passwords of all the users. For people who reuse passwords, this could be catastrophic to their online identity. We're going to solve this using the standard technique of hashing and salting. This section will explain what hashing and salting are, and why we use them; and will then provide you with the guidance you need to implement them in `controller.rb`.

A hash function is a mathematical function that maps some piece of data of arbitrary size to a corresponding piece of data (a bit string) of fixed size. The key idea here is collision resistance, one should not be able to find two pieces of data that the hash function maps to the same bit string.

A cryptographic hash function is a hash function used for sensitive data (like passwords); as such, it has the additional property of being a one-way function, a function that is difficult (i.e. intractable) to invert. Given a good hash, it should be relatively easy to hash a password. However, if someone gives me a password that they just hashed, it should be very hard for me to figure out what the password originally was. Lastly, the input to a cryptographic hash function is usually called the message, and the (hashed) output is usually called the digest.

How is this used in practice? Rather than storing a user's actual password, we immediately hash it and store the hashed value. Then, whenever a user tries to log in, we hash the password the user gives, and check that the hashed value matches what is stored in the database.

However, before you go hashing users' passwords and imagining that this is secure, ask yourself: do you really trust users to come up with good passwords? Have you ever thought how often a user simply uses "password" as their password? Cryptographic hashing aside, imagine the following: an attacker somehow gets ahold of a web app's Users table, replete with usernames and hashed passwords. To recover the original passwords, he downloads a dictionary (called a rainbow table) with millions or more common password hashes until he finds a match from the web app's database. If the hashes match, that plain-text password is likely the user's password. To prevent this, we will salt the users' passwords.

This means that, whenever a user creates an account or changes his or her password, we generate a new random salt (i.e., some bit string) that we store in the same table where the password is kept. Rather than hash their password, we hash the concatenation: password + salt. This is essentially a way of strengthening a user's password and rendering it harder (though certainly not impossible) to discover using a dictionary attack. If your salt is only 16 bits long, then there are only 65,536 possible salts so the attacker need only hash 65,536 password + salt combinations per password in his or her lookup table. Given a relatively fast hashing function (like SHA-2), this won't take very long on a modern GPU. Per this project you can generate the salt however you see fit (but please within the spirit of the project). We recommend using `SecureRandom.hex`.

To make the attacker's job too difficult to be worth it, we use a long salt; a rule of thumb would have us pick a salt that's the same length as the hashing function's output, in this case 256 bits (or 32 bytes). To do this, we use a cryptographically secure pseudo-random number generator (CSPRNG) that someone else has designed?never try to make up your own functions for cryptographic hashing or salt-generation! This is not the same as a normal, run-of-the-mill random number generator; CSPRNGs are required to be proven to pass certain tests of statistical randomness (e.g., the next-bit test) and are typically written by professional mathematicians. The same goes for cryptographic hashing functions, do not try and write your own.
